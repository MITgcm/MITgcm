#!/bin/bash
#
#  $Header: /u/gcmpack/MITgcm/verification/testreport,v 1.14 2003/11/07 21:32:19 edhill Exp $
#  $Name:  $
#

usage()
{
    echo
    echo "Usage:  $0 [OPTIONS]"
    echo
    echo "where possible OPTIONS are:"
    echo "  (-help|-h)               print usage"
    echo "  (-mpi)                   use MPI input files"
    echo "  (-ieee|-noieee)          if possible, use IEEE compiler flags"
    echo "  (-optfile=|-of=)STRING   list of optfiles to use"
    echo "  (-a|-addr)STRING         list of email recipients"
    echo "                             (DEF=\"edhill@mitgcm.org\")"
    echo "  (-t|-tdir)STRING         list of test dirs to use"
    echo "                             (DEF=\"\" which builds all)"
    echo "  (-b|-bash)STRING         location of \"bash\" executable"
    echo "                             (DEF=\"\" for \"/bin/bash\")"
    echo "  (-command)STRING         command to run"
    echo "                             (DEF=\"make output.txt\")"
    echo "  (-m|-make)STRING         command to use for \"make\""
    echo "                             (DEF=\"make\")"
    echo "  (-clean)                 *ONLY* run \"make CLEAN\""
    echo "  (-quick|-q)              same as \"-nogenmake -noclean -nodepend\""
    echo "  (-nogenmake|-ng)         skip the genmake stage"
    echo "  (-noclean|-nc)           skip the \"make clean\" stage"
    echo "  (-nodepend|-nd)          skip the \"make depend\" stage"
    echo
    echo "and where STRING follows a whitespace-delimited format"
    echo "such as:"
    echo "  -t 'exp0 exp2 exp3' "
    echo "  -addr='abc@123.com testing@home.org'"
    echo
    exit 1
}

#  build the mpack utility
build_mpack()
{
    echo -n "building the mpack utility...  "
    if test ! -x "$MPACKDIR/mpack" ; then
	if test ! -d $MPACKDIR ; then
	    echo "Error: can't find \"$MPACKDIR\""
	    echo "  are you sure this program is being run in the correct "
	    echo "  (that is, \"MITGCM_ROOT\verification\") directory?"
	    exit 1
	fi
	echo -n "building mpack...  "
	( cd $MPACKDIR && ./configure && $MAKE ) > build_mpack.out 2>&1
	RETVAL=$?
	if test "x$RETVAL" != x0 ; then
	    echo
	    echo "Error building the mpack tools at: $MPACK_DIR"
	    exit 1
	fi
    fi
    echo "OK"
}

compare_lines()
{
    # use codelet to compare lines
    if [ $verbose -gt 1 ]; then
	cat tmp3.txt 1>&2
    fi
    return `./a.out < tmp3.txt`
}

testoutput_for_prop()
{
    # testoutput_for_prop dir s1 label subdir
    #
    #  compares files in $dir/$subdir/output.txt and $dir/results/output.txt
    #  using search strings s1 and text label 

    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: grep "$2" $1/$4/output.txt 1>&2
    fi
    if [ -r $1/$4/output.txt ]; then
	grep "$2" $1/$4/output.txt | sed 's/.*=//' | nl > tmp1.txt
	lncnt=`wc -l tmp1.txt | awk '{print $1}' `
	if [ $lncnt -lt 3 ]; then
	    if [ $verbose -gt 0 ]; then
		echo Not enough lines of output when searching for "$2" 1>&2
	    fi
	    return 99
	fi
    else
	echo testoutput_for_prop: output.txt from model run was not readable 1>&2
	return 99
    fi
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: grep "$2" $1/results/output.txt 1>&2
    fi
    grep "$2" $1/results/output.txt | sed 's/.*=//' | nl > tmp2.txt
    lncnt=`wc -l tmp2.txt | awk '{print $1}' `
    if [ $lncnt -lt 3 ]; then
	if [ $verbose -gt 0 ]; then
	    echo Not enough lines of output when searching for "$2" 1>&2
	fi
	return 99
    fi
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: join tmp1.txt tmp2.txt 1>&2
    fi
    join tmp1.txt tmp2.txt | awk '{print $1 " " $2 " " $3}' > tmp3.txt
    if [ $debug -gt 0 ]; then
	echo testoutput_for_prop: compare_lines 1>&2
    fi
    compare_lines
    digits_of_similarity=$?
    if [ $digits_of_similarity -eq 99 ]; then
	if [ $verbose -gt 0 ]; then
	    echo testoutput_for_prop: No comparison was available for \"$2\" 1>&2
	fi
	digits_of_similarity=99
    else
	if [ $verbose -gt 0 ]; then
	    echo There were $digits_of_similarity decimal places of similarity for \"$2\" 1>&2
	fi
    fi
    rm tmp1.txt tmp2.txt tmp3.txt
    
    return $digits_of_similarity
}

dashnum()
{
    # dashnum n1 n2 n3 ...
    #
    #  print numbers using %3i format or "--" if number = 99

    for num in $@ ; do
	if [ $num = 99 ]; then
	    printf ' --'
	else
	    printf '%3i' $num
	fi
    done
}

testoutput()
{
    # testoutput diretory subdir
    #
    #  test output in "directory"

    if [ $debug -gt 0 ]; then
	echo testoutput: testoutput_for_prop $1 cg2d_init_res 1>&2
    fi
    testoutput_for_prop $1 "cg2d_init_res" "cg2d init. residual" $2; cg2dres=$?
    if [ $debug -gt 0 ]; then
	echo testoutput: cg2dres=$cg2dres 1>&2
    fi
    testoutput_for_prop $1 "dynstat_theta_min" "theta minimum" $2; tmin=$?
    testoutput_for_prop $1 "dynstat_theta_max" "theta maximum" $2; tmax=$?
    testoutput_for_prop $1 "dynstat_theta_mean" "theta mean" $2; tmean=$?
    testoutput_for_prop $1 "dynstat_theta_sd" "theta s.d." $2; tsd=$?
    testoutput_for_prop $1 "dynstat_salt_min" "salt minimum" $2; smin=$?
    testoutput_for_prop $1 "dynstat_salt_max" "salt maximum" $2; smax=$?
    testoutput_for_prop $1 "dynstat_salt_mean" "salt mean" $2; smean=$?
    testoutput_for_prop $1 "dynstat_salt_sd" "salt s.d." $2; ssd=$?
    testoutput_for_prop $1 "dynstat_uvel_min" "U minimum" $2; umin=$?
    testoutput_for_prop $1 "dynstat_uvel_max" "U maximum" $2; umax=$?
    testoutput_for_prop $1 "dynstat_uvel_mean" "U mean" $2; umean=$?
    testoutput_for_prop $1 "dynstat_uvel_sd" "U s.d." $2; usd=$?
    testoutput_for_prop $1 "dynstat_vvel_min" "V minimum" $2; vmin=$?
    testoutput_for_prop $1 "dynstat_vvel_max" "V maximum" $2; vmax=$?
    testoutput_for_prop $1 "dynstat_vvel_mean" "V mean" $2; vmean=$?
    testoutput_for_prop $1 "dynstat_vvel_sd" "V s.d." $2; vsd=$?
    
    dashnum $cg2dres $tmin $tmax $tmean $tsd $smin $smax $smean $ssd \
        $umin $umax $umean $usd $vmin $vmax $vmean $vsd
}

genmakemodel()
{
    # genmakemodel directory
    if test "x$NOGENMAKE" = xt ; then
	echo "genmake skipped!"
    else
	GENMAKE2="$BASH ../../../tools/genmake2"
	(
	    cd $1;
	    command="$GENMAKE2  -ds -m $MAKE --mods=../code"
	    if test "x$OPTFILE" != xNONE ; then
		command="$command --optfile=$OPTFILE"
		# echo "  command=\"$command\""
	    fi
	    if test "x$IEEE" != x ; then
		command="$command -ieee"
	    fi
	    # echo "command: \"$command\""
	    printf 'genmake ... ' 1>&2
	    $command > make.log 2>&1
	    RETVAL=$?
	    for i in genmake_state genmake_optfile genmake_local Makefile ; do
		if test -r $i ; then
		    cp $i $CDIR
		fi
	    done
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo "genmakemodel: genmake failed" 1>&2
		cp make.log $CDIR
		return 1
	    else
		echo "succesful" 1>&2
	    fi
	)
    fi
}

makeclean()
{
    # makeclean directory
    if test "x$NOCLEAN" = xt ; then
	echo "make CLEAN skipped!"
    else
	(
	    cd $1;
	    if test -e output.txt ; then
		rm -f output.txt
	    fi
	    printf 'make CLEAN ... ' 2>&1
	    if test -r Makefile ; then
		$MAKE CLEAN >> make.log 2>&1
		RETVAL=$?
		if test "x$RETVAL" != x0 ; then
		    tail make.log
		    echo "makeclean: \"make CLEAN\" failed" 1>&2
		    cp make.log $CDIR"/make.log"
		    return 1
		fi
	    fi
	    echo succesful 1>&2
	    exit 0
	)
    fi
}

makedependmodel()
{
    # makedependmodel directory
    if test "x$NODEPEND" = xt ; then
	echo "make depend skipped!"
    else
	(
	    cd $1;
	    printf 'make depend ... ' 1>&2
	    $MAKE depend >> make.log 2>&1
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo "makedependmodel: make depend failed" 1>&2
		cp make.log $CDIR"/make.log"
		return 1
	    else
		echo succesful 1>&2
	    fi
	)
    fi
}

makemodel()
{
    # makemodel directory
    (
	cd $1;
	if test -r Makefile ; then
	    printf 'make ... ' 1>&2
	    $MAKE >> make.log 2>&1
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		tail make.log
		echo failed 1>&2
		cp make.log $CDIR"/make.log"
		return 1
	    else
		echo succesful 1>&2
	    fi
	fi
    )
}

linkdata()
{
    # linkdata flag
    #
    # symbolically link data files to run directory
    if test "x$1" = x1 ; then
	(
	    cd $2
	    files=`( cd ../input ; ls -1 | grep -v CVS )`
	    for i in $files ; do
		if test ! -d "../input/"$i ; then
		    ln -sf "../input/"$i $i
		fi
	    done
	)
    fi
}

runmodel()
{
    # runmodel directory
    #
    #  runs "$COMMAND" in "directory" 
    #  (where "$COMMAND" is relative to "directory")
    (
	cd $1
	printf 'runmodel: ' 1>&2
	# make output.txt
	$COMMAND
	RETVAL=$?
	if test "x$RETVAL" = x0 ; then
	    cp output.txt $CDIR"/output.txt"
	    return 0
	else
	    return 1
	fi
    )
}

createcodelet()
{
    # create codelet for comparing model output

    echo -n "creating the comparison code...  "
    cat > tmp_cmpnum.f <<EOFA
      program cmpnum
      implicit none
      real*8 a,b,diff
      integer linnum,best
      best=-16
  99  read(*,*,end=70,err=60) linnum,a,b
      diff=0.5*(abs(a)+abs(b))
c     print *,a,b,diff,abs(a-b)/diff
      if (diff.gt.1.e-12) then
        diff=abs(a-b)/diff
        if (diff.gt.0.) then
c         print *,int(log10(diff)),diff
          linnum=int(log10(diff))
          best=max(best,linnum)
        endif
      else
        if (best.eq.-16.and.diff.ne.0.) best=-22
      endif
      goto 99
  60  stop 'cmpnum: An error occured reading a,b'
  70  print *,-best
      end
EOFA

    f77 tmp_cmpnum.f
    if [ -x ./a.out ]; then
	echo "OK"
	return 0
    else
	echo
	echo "createcodelet: failed to compile codelet" 
	exit 1
    fi
}

formatresults()
{
    # formatresults expt genmake depend make run results*

    nm=$1
    printf '%s %s %s %s' $2 $3 $4 $5
    shift; shift; shift; shift; shift;
    printf '%3s' $@
    
    if [ $1 = '--' ]; then
	printf ' N/O '
    else
	if [ $1 -gt 12 ]; then
	    printf ' pass'
	else
	    printf ' FAIL'
	fi
    fi
    printf '  %s' $nm
    printf '\n'
    
}

show_help()
{
    cat - << EOF
$0 [-help] [-quick] [-verbose] dir1 [dir2] [...]

 -help|-h      Show this help message
 -quiet     Reduce the amount of output
 -verbose   Produce copious amounts of output
 -debug     Produce even more output which will mean nothing to most
 -force     Do "make CLEAN" before compiling. This forces a complete rebuild.
 -clean     Do "make CLEAN" after compiling and testing.
 -cleanup   Aggresively removes all model output, executables and object files
            and then exits. Use with care.

Normal usage:
 $0 *       Configure, compile, run and analyze in all experiment directories
EOF
}

scandirs()
{
    if [ $# -eq 0 ]; then
	for arg in * ; do
	    test -d $arg/input && echo $arg
	done
    else
	echo $*
    fi
}


###############################################################################
###############################################################################
###############################################################################


#  Default properties
debug=0
verbose=1
clean=0
expts=''
# ieee=1

IEEE=
if test "x$MITGCM_IEEE" != x ; then
    IEEE=$MITGCM_IEEE
fi


CLEANUP=f
QUICK=f
NOGENMAKE=f
NOCLEAN=f
NODEPEND=f

BASH=
OPTFILE=NONE
ADDRESSES=
TESTDIRS=
MPACKDIR="../tools/mpack-1.6"
MPACK="$MPACKDIR/mpack"
COMMAND="make output.txt"
MAKE=make
MPI=f

echo -n "parsing options...  "

ac_prev=
for ac_option ; do

    # If the previous option needs an argument, assign it.
    if test -n "$ac_prev"; then
        eval "$ac_prev=\$ac_option"
        ac_prev=
        continue
    fi

    ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
    
    case $ac_option in
	
	-help | --help | -h | --h)
	    usage ;;
	
	-optfile | --optfile | -of | --of)
            ac_prev=OPTFILE ;;
        -optfile=* | --optfile=* | -of=* | --of=*)
            OPTFILE=$ac_optarg ;;
	
	-addr | --addr | -a | --a)
            ac_prev=ADDRESSES ;;
        -addr=* | --addr=*)
            ADDRESSES=$ac_optarg ;;

	-tdir | --tdir | -t | --t)
            ac_prev=TESTDIRS ;;
        -tdir=* | --tdir=*)
            TESTDIRS=$ac_optarg ;;

	-bash | --bash | -b | --b)
            ac_prev=BASH ;;
        -bash=* | --bash=*)
            BASH=$ac_optarg ;;

	-command | --command | -c | --c)
	    ac_prev=COMMAND ;;
	-command=* | --command=*)
	    COMMAND=$ac_optarg ;;

	-make | --make | -m | --m)
	    ac_prev=MAKE ;;
	-make=* | --make=*)
	    MAKE=$ac_optarg ;;

	-clean | --clean)
	    CLEANUP=t ;;

	-quick | --quick | -q | --q)
	    QUICK=t ;;
	-nogenmake | --nogenmake | -ng | --ng)
	    NOGENMAKE=t ;;
	-noclean | --noclean | -nc | --nc)
	    NOCLEAN=t ;;
	-nodepend | --nodepend | -nd | --nd)
	    NODEPEND=t ;;

	-mpi) MPI=true ;;

	-ieee) IEEE=true ;;
	-noieee) IEEE= ;;

	-verbose) verbose=2 ;;
	-debug) debug=1 ;;
	-quiet) verbose=0 ;;

        -*)
            echo "Error: unrecognized option: "$ac_option
            usage
            ;;
        
        *)
            echo "Error: unrecognized argument: "$ac_option
            usage
            ;;
        
     esac
     
done

if test "x$QUICK" = xt ; then
    NOGENMAKE=t
    NOCLEAN=t
    NODEPEND=t
fi

if test "x$TESTDIRS" = x ; then
    TESTDIRS=`scandirs`
fi

if test "x$OPTFILE" = xNONE -a "x$MITGCM_OF" != x ; then
    OPTFILE=$MITGCM_OF
fi

echo "OK"

#  create the FORTRAN comparison code
createcodelet

#  build the mpack utility
build_mpack

#  Create a uniquely named directory to store results
MACH=`hostname`
UNAMEA=`uname -a`
DATE=`date +%Y%m%d`
BASE=$MACH"_"$DATE"_"
DNUM=0
DRESULTS="$BASE$DNUM"
while test -e $DRESULTS ; do
    DNUM=$(( $DNUM + 1 ))
    DRESULTS="$BASE$DNUM"
done
mkdir $DRESULTS
RETVAL=$?
if test "x$RETVAL" != x0 ; then
    echo "Error: can't create results directory \"./$DRESULTS\""
    exit 1
fi
SUMMARY="$DRESULTS/summary.txt"
echo -n "Start time:  " >> $SUMMARY
date > $SUMMARY
date > dfile
cat << EOF >> $SUMMARY
                T           S           U           V
G D M    c        m  s        m  s        m  s        m  s
E p a R  g  m  m  e  .  m  m  e  .  m  m  e  .  m  m  e  .
N n k u  2  i  a  a  d  i  a  a  d  i  a  a  d  i  a  a  d
2 d e n  d  n  x  n  .  n  x  n  .  n  x  n  .  n  x  n  .

EOF

NDIR=0

of_path=
if test "x$OPTFILE" != xNONE ; then
    if test -r $OPTFILE ; then
	# get the path
	path=${OPTFILE%/*}
	if test "x$path" = x ; then
	    of_path=`pwd`
	else
	    of_path=`( cd $path > /dev/null 2>&1 ; pwd )`
	fi
	file=${OPTFILE##*/}
	OPTFILE=$of_path/$file
    else
	echo
	echo "WARNING: can't read OPTFILE=\"$OPTFILE\" but will try to use it..."
    fi
fi
echo
echo "OPTFILE=$OPTFILE" >> $SUMMARY
echo >> $SUMMARY

#  ...and each test directory...
for dir in $TESTDIRS ; do
    
    #  Cleanup only!
    if test "x$CLEANUP" = xt ; then
	if test -r $dir/build/Makefile ; then
	    ( cd $dir/build ; make CLEAN )
	fi
	if test -r $dir/input/Makefile ; then
	    ( cd $dir/input ; make CLEAN )
	fi
	continue
    fi

    #  Verify that the testdir exists and contains previous 
    #  results in the correct location--or skip this directory!
    if test ! -r $dir"/results/output.txt" ; then
	echo "can't read \"$dir/results/output.txt\" -- skipping $dir"
	continue
    fi

    echo "-------------------------------------------------------------------------------"
    echo
    echo "Experiment:  $dir"
    echo
    unset genmake makedepend make run
    results='-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --'

    builddir="input"
    rundir="input"
    use_seperate_build=0
    if test -d $dir/build -a -r $dir/build ; then
	builddir="build"
	rundir="build"
	use_seperate_build=1
	linkdata $use_seperate_build $dir/$rundir
    fi
    
    CODE_DIR=$dir/code
    BUILD_DIR=$dir/$builddir
    MPI_FILES="CPP_EEOPTIONS.h_mpi SIZE.h_mpi"
    NOMPI_FILES="CPP_EEOPTIONS.h_nompi SIZE.h_nompi"

    #  Is this an MPI run?
    if test "x$MPI" = xt ; then
	FILES=$MPI_FILES
	endings="_mpi"
    else
	FILES=$NOMPI_FILES
	endings="_nompi"
    fi
    
    #  Check to see that we have the files
    have_files=t
    for i in $FILES ; do
	if test ! -r $CODE_DIR/$i ; then
	    echo "Warning: can't read file $CODE_DIR/$i"
	    have_files=f
	fi
    done
    if test "x$have_files" != xt -a "x$MPI" = xt ; then
	echo "Skipping $dir due to lack of input files (see above warning)"
	continue
    fi
    
    #  If we have the $FILES and they differ, copy the $FILES to $BUILD_DIR
    if test "x$have_files" = xt ; then
	for i in $FILES ; do
	    sstr="s|$endings||"
	    name=`echo $i | sed -e $sstr `
	    cmp $CODE_DIR/$i $BUILD_DIR/$name > /dev/null 2>&1
	    RETVAL=$?
	    if test "x$RETVAL" != x0 ; then
		cp $CODE_DIR/$i $BUILD_DIR/$name
	    fi
	done
    fi
    
    #  Create an output dir for each OPTFILE/tdir combination
    CDIR=$DRESULTS"/"$DRESULTS"_"$NDIR
    mkdir $CDIR
    CDIR=`pwd`"/$CDIR"
    
    if test "x$CLEANUP" = xt ; then
	makeclean $dir/$builddir
    else
	genmakemodel $dir/$builddir && genmake=Y \
	    && makeclean $dir/$builddir \
	    && makedependmodel $dir/$builddir && makedepend=Y \
	    && makemodel $dir/$builddir && make=Y \
	    && linkdata $use_seperate_build $dir/$rundir \
	    && runmodel $dir/$rundir && run=Y \
	    && results=`testoutput $dir $rundir`
    fi
    
    echo
    formatresults $dir ${genmake:-N} ${makedepend:-N} ${make:-N} \
	${run:-N} $results
    echo
    formatresults $dir ${genmake:-N} ${makedepend:-N} ${make:-N} \
	${run:-N} $results >> $SUMMARY
    echo "fresults='" > $CDIR"/summary.txt"
    formatresults $dir ${genmake:-N} ${makedepend:-N} ${make:-N} \
	${run:-N} $results >> $CDIR"/summary.txt"
    echo "'" >> $CDIR"/summary.txt"
    echo "MACH='$MACH'" >> $CDIR"/summary.txt"
    echo "UNAMEA='$UNAMEA'" >> $CDIR"/summary.txt"
    echo "DATE='$DATE'" >> $CDIR"/summary.txt"
    echo "tdir='$dir'" >> $CDIR"/summary.txt"
    
    (
	cd $DRESULTS
	tar -cf $NDIR".tar" $DRESULTS"_"$NDIR > /dev/null 2>&1
	gzip $NDIR".tar"
    )
    
    if test "x$ADDRESSES" = xNONE -o "x$ADDRESSES" = x ; then
	echo "No mail sent"
    else
	$MPACK -s MITgcm-test -m 1000000 $DRESULTS"/"$NDIR".tar.gz" $ADDRESSES
	RETVAL=$?
	if test "x$RETVAL" != x0 ; then
	    echo "Warning: \"$MPACK\" failed -- please contact <edhill@mitgcm.org>"
	else
	    rm -f $DRESULTS"/"$NDIR".tar*"
	fi
    fi

    echo "-------------------------------------------------------------------------------"
    
    NDIR=$(( $NDIR + 1 ))
    
done

echo -n "Start time:  " >> $SUMMARY
date -r dfile >> $SUMMARY
echo -n "End time:    " >> $SUMMARY
date >> $SUMMARY

rm tmp_cmpnum.f a.out dfile

if test "x$CLEANUP" != xt ; then
    cat $SUMMARY
    if test -e tr.out ; then
        mv tr.out tr.out.old
    fi
    cat $SUMMARY > tr.out
fi

