#include "AUTODIFF_OPTIONS.h"

CBOP
C     !ROUTINE: CG2D_SAD
C     !INTERFACE:
      SUBROUTINE CG2D_SAD(
     U                    cg2d_b_ad, cg2d_x, cg2d_x_ad,
     U                    numIters, nIterMin,
     I                    myThid )
C     !DESCRIPTION: \bv
C     *==========================================================*
C     | SUBROUTINE CG2D_SAD
C     | o Self-ADjoint version of CG2D, the two-dimensional
C     |   grid problem conjugate-gradient inverter.
C     *==========================================================*
C     | This routine is called from solve_for_pressure_ad that
C     | is generated by TAF/TAMC. We want a self-adjoint cg2d
C     | to avoid too many complications, so we provide flow
C     | directives in cg2d.flow and fake it here.
C     | This routine calls cg2d with reversed order of argumgent
C     | cg2d_x_ad and cg2d_b_ad, and sets dependendcies to zero
C     | that a non-self-adjoint cg2d would have produced.
C     *==========================================================*
C     \ev

C     !USES:
      IMPLICIT NONE
C     === Global data ===
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#include "CG2D.h"
#include "AUTODIFF_PARAMS.h"

C     !INPUT/OUTPUT PARAMETERS:
C     === Routine arguments ===
C     cg2d_b_ad :: Adjoint of source term
C     cg2d_x_ad :: Adjoint of the solution
C     cg2d_x    :: The solution (only input)
C     firstResidual :: the initial residual before any iterations
C     minResidualSq :: the lowest residual reached (squared)
C     lastResidual  :: the actual residual reached
C     numIters  :: Inp: the maximum number of iterations allowed
C                  Out: the actual number of iterations used
C     nIterMin  :: Inp: decide to store (if >=0) or not (if <0) lowest res. sol.
C                  Out: iteration number corresponding to lowest residual
C     myThid    :: Thread on which I am working.
      _RL  cg2d_b_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL  cg2d_x_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL  cg2d_x   (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
c     _RL  firstResidual, minResidualSq, lastResidual
      INTEGER numIters
      INTEGER nIterMin
      INTEGER myThid

#ifdef ALLOW_AUTODIFF_TAMC
#ifdef NONLIN_FRSURF
C     directly imported from TAF-generated code, make sure that they are
C     consistent with what is found in S/R update_cg2d_ad
      _RL aW2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aS2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aC2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pW_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pS_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pC_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      COMMON /CG2D_I_R_AD/
     &     aW2d_ad, aS2d_ad, aC2d_ad, pW_ad, pS_ad, pC_ad

      _RL cg2dTmp(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
#endif /* NONLIN_FRSURF */

C     !LOCAL VARIABLES:
C     === Local variables ===
C     bi,bj  :: tile indices
C     i,j    :: Loop counters
      INTEGER i,j,bi,bj
      _RL  firstResidual, minResidualSq, lastResidual
#ifdef NONLIN_FRSURF
      _RL  recip_cg2dNorm
#endif
CEOP

C--   mark output of cg2d as being called from here
      IF ( debugLevel .GE. debLevZero ) THEN
       _BEGIN_MASTER( myThid )
       WRITE(standardmessageunit,'(A)')
     &      ' Calling cg2d from S/R CG2D_SAD'
       _END_MASTER( myThid )
      ENDIF

#ifdef NONLIN_FRSURF
      recip_cg2dNorm = 1.0 _d 0
      IF ( cg2dNorm .NE. 0. _d 0 ) THEN
       recip_cg2dNorm = 1./cg2dNorm
      ENDIF

      IF ( cg2dFullAdjoint ) THEN
C     Save input cg2d_b_ad, not sure if this is necessary.
       DO bj = myByLo(myThid), myByHi(myThid)
        DO bi = myBxLo(myThid), myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
           cg2dTmp(i,j,bi,bj) = cg2d_b_ad(i,j,bi,bj)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF */

#ifdef ALLOW_SRCG
      IF ( useSRCGSolver ) THEN
C--   Call the single reduce CG solver
       CALL CG2D_SR(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ELSE
#else
      IF (.TRUE.) THEN
#endif /* ALLOW_SRCG */
C--   Call the default CG solver
       CALL CG2D(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ENDIF

      DO bj=myByLo(myThid),myByHi(myThid)
       DO bi=myBxLo(myThid),myBxHi(myThid)
        DO j=1-OLy,sNy+OLy
         DO i=1-OLx,sNx+OLx
C     cg2d_x_ad is reset to zero, because we assume that the solution of
C     the self-adjoint solver does not depend in the intial conditions
C     so that no sensitivities should be passed back to the caller.
          cg2d_x_ad(i,j,bi,bj) = 0. _d 0
         ENDDO
        ENDDO
       ENDDO
      ENDDO

#ifdef NONLIN_FRSURF
      IF ( cg2dFullAdjoint ) THEN
C     Compute derivative of coefficient matrix.
       _EXCH_XY_RL( cg2d_b_ad, myThid )
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=2-OLy,sNy+OLy-1
          DO i=2-OLx,sNx+OLx-1
           aC2d_ad(i,j,bi,bj)   = aC2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i,  j,bi,bj) =  aW2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i-1,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i+1,j,bi,bj) =  aW2d_ad(i+1,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i+1,j,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j,  bi,bj) = aS2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j-1,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j+1,bi,bj) = aS2d_ad(i,j+1,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j+1,bi,bj)
     &          * recip_cg2dNorm
           pW_ad  (i,j,bi,bj) = 0. _d 0
           pS_ad  (i,j,bi,bj) = 0. _d 0
           pC_ad  (i,j,bi,bj) = 0. _d 0
CML why do we need this? Isnt that counting things twice?
           cg2d_b_ad(i,j,bi,bj) = cg2d_b_ad(i,j,bi,bj)
     &          + cg2dTmp(i,j,bi,bj)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ELSE
C     Initialise AD fields to zero. They will not have any effect on
C     the solution, because we fake the AD code of cg2d.
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
          aW2d_ad(i,j,bi,bj) = 0. _d 0
          aS2d_ad(i,j,bi,bj) = 0. _d 0
          aC2d_ad(i,j,bi,bj) = 0. _d 0
          pW_ad  (i,j,bi,bj) = 0. _d 0
          pS_ad  (i,j,bi,bj) = 0. _d 0
          pC_ad  (i,j,bi,bj) = 0. _d 0
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF */
#endif /* ALLOW_AUTODIFF_TAMC */

      RETURN
      END
