#include "AUTODIFF_OPTIONS.h"
#ifdef "ALLOW_CTRL"
# include "CTRL_OPTIONS.h"
#endif

C--   File cg2d_sad.F: Code for hand written adjoint of cg2d
C--    Contents
C--   CG2D_SAD        - computes the adjoint of cg2d
C--   CG2D_STORE      - saves input field to or restores from a common block
C--   CG2D_STORE_AD   - empty AD-version of CG2D_STORE

CBOP
C     !ROUTINE: CG2D_SAD
C     !INTERFACE:
      SUBROUTINE CG2D_SAD(
     U                    cg2d_b_ad,
     I                    cg2d_x,
     U                    cg2d_x_ad,
     U                    numIters, nIterMin,
     I                    myThid )
C     !DESCRIPTION: \bv
C     *==========================================================*
C     | SUBROUTINE CG2D_SAD
C     | o Self-ADjoint version of CG2D, the two-dimensional
C     |   grid problem conjugate-gradient inverter.
C     *==========================================================*
C     | This routine is called from solve_for_pressure_ad that
C     | is generated by TAF/TAMC. We want a self-adjoint cg2d
C     | to avoid too many complications, so we provide flow
C     | directives in cg2d.flow and fake it here.
C     | This routine calls cg2d with reversed order of argumgent
C     | cg2d_x_ad and cg2d_b_ad, and sets dependendcies to zero
C     | that a non-self-adjoint cg2d would have produced.
C     | In addition, when runtime parameter cg2dFullAdjoint = T,
C     | add compute sensitivities to matrix coefficients, where
C     | possible. This makes is the full adjoint of cg2d, only
C     | if cg2d is completely converged. Otherwise it is a very
C     | good approximation.
C     *==========================================================*
C     \ev

C     !USES:
      IMPLICIT NONE
C     === Global data ===
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
# include "CG2D.h"
#endif
#ifdef ALLOW_AUTODIFF_TAMC
# include "AUTODIFF_PARAMS.h"
#endif

C     !INPUT/OUTPUT PARAMETERS:
C     === Routine arguments ===
C     cg2d_b_ad :: Adjoint of source term (on input = 0)
C     cg2d_x_ad :: Adjoint of the solution
C     cg2d_x    :: First guess of cg2d ( gravity * etaN, only input )
C     firstResidual :: the initial residual before any iterations
C     minResidualSq :: the lowest residual reached (squared)
C     lastResidual  :: the actual residual reached
C     numIters  :: Inp: the maximum number of iterations allowed
C                  Out: the actual number of iterations used
C     nIterMin  :: Inp: decide to store (if >=0) or not (if <0) lowest res. sol.
C                  Out: iteration number corresponding to lowest residual
C     myThid    :: Thread on which I am working.
      _RL  cg2d_b_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL  cg2d_x_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL cg2d_x    (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
c     _RL  firstResidual, minResidualSq, lastResidual
      INTEGER numIters
      INTEGER nIterMin
      INTEGER myThid

#ifdef ALLOW_AUTODIFF_TAMC
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
C     directly imported from TAF-generated code, make sure that they are
C     consistent with what is found in S/R update_cg2d_ad
      _RL aW2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aS2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aC2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pW_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pS_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pC_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      COMMON /CG2D_I_R_AD/
     &     aW2d_ad, aS2d_ad, aC2d_ad, pW_ad, pS_ad, pC_ad
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */

C     !LOCAL VARIABLES:
C     === Local variables ===
C     bi,bj  :: tile indices
C     i,j    :: Loop counters
      INTEGER i,j,bi,bj
      _RL  firstResidual, minResidualSq, lastResidual
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      _RL  recip_cg2dNorm
#endif
C     CHARACTER*(MAX_LEN_MBUF) msgBuf
CEOP

C--   mark output of cg2d as being called from here
      IF ( debugLevel .GE. debLevZero ) THEN
       _BEGIN_MASTER( myThid )
       WRITE(standardmessageunit,'(A)')
     &      ' Calling cg2d from S/R CG2D_SAD'
       _END_MASTER( myThid )
      ENDIF

#ifdef ALLOW_SRCG
      IF ( useSRCGSolver ) THEN
C--   Call the single reduce CG solver
       CALL CG2D_SR(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ELSE
#else
      IF (.TRUE.) THEN
#endif /* ALLOW_SRCG */
C--   Call the default CG solver
       CALL CG2D(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ENDIF

C     cg2d_x_ad is reset to zero, because we assume that the solution of
C     the self-adjoint solver does not depend in the intial conditions
C     so that no sensitivities should be passed back to the caller.
      DO bj=myByLo(myThid),myByHi(myThid)
       DO bi=myBxLo(myThid),myBxHi(myThid)
        DO j=1-OLy,sNy+OLy
         DO i=1-OLx,sNx+OLx
          cg2d_x_ad(i,j,bi,bj) = 0. _d 0
         ENDDO
        ENDDO
       ENDDO
      ENDDO

C--   dump CG2D output
C     Since there is no clean way in importing myTime into this routine,
C     we just have this here commented out, in case it is needed.
C      IF ( .TRUE. !DIFFERENT_MULTIPLE(monitorFreq,myTime,deltaTClock)
C     &   ) THEN
C       IF ( debugLevel .GE. debLevA ) THEN
C        _BEGIN_MASTER( myThid )
C        WRITE(msgBuf,'(A30,1PE23.14)')
C     &       'CG2D_SAD: cg2d_init_res =',firstResidual
C        CALL PRINT_MESSAGE(msgBuf,standardMessageUnit,SQUEEZE_RIGHT,1)
C        WRITE(msgBuf,'(A37,2I8)')
C     &       'CG2D_SAD: cg2d_iters(min,last) =', nIterMin, numIters
C        CALL PRINT_MESSAGE(msgBuf,standardMessageUnit,SQUEEZE_RIGHT,1)
C        IF ( minResidualSq.GE.0. ) THEN
C         minResidualSq = SQRT(minResidualSq)
C         WRITE(msgBuf,'(A30,1PE23.14)')
C     &        'CG2D_SAD: cg2d_min_res  =',minResidualSq
C         CALL PRINT_MESSAGE(msgBuf,standardMessageUnit,SQUEEZE_RIGHT,1)
C        ENDIF
C        WRITE(msgBuf,'(A30,1PE23.14)')
C     &       'CG2D_SAD: cg2d_last_res =',lastResidual
C        CALL PRINT_MESSAGE(msgBuf,standardMessageUnit,SQUEEZE_RIGHT,1)
C        _END_MASTER( myThid )
C       ENDIF
C      ENDIF

#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      recip_cg2dNorm = 1.0 _d 0
      IF ( cg2dNorm .NE. 0. _d 0 ) THEN
       recip_cg2dNorm = 1./cg2dNorm
      ENDIF

      IF ( cg2dFullAdjoint ) THEN
C     Compute derivative of coefficient matrix.
       _EXCH_XY_RL( cg2d_b_ad, myThid )
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=2-OLy,sNy+OLy-1
          DO i=2-OLx,sNx+OLx-1
           aC2d_ad(i,j,bi,bj)   = aC2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i,  j,bi,bj) =  aW2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i-1,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i+1,j,bi,bj) =  aW2d_ad(i+1,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i+1,j,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j,  bi,bj) = aS2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j-1,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j+1,bi,bj) = aS2d_ad(i,j+1,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j+1,bi,bj)
     &          * recip_cg2dNorm
C     The sensitivities of preconditioner are something like
C          pC_ad = pC_ad + cg2d_z_ad * cg2d_r
C     and similar (cg2d_z = preconditioner * cg2d_r). That is, when the
C     solver has converged, cg2d_r -> 0 and pC_ad -> 0, unless cg2d_z_ad
C     is large, which would mean an instability. Therefore we set the
C     preconditioner adjoint to zero. This also reflects the fact, that
C     in an ideal world, the preconditioner does not have any effect on
C     the solution, but only on the rate of convergence.
           pW_ad(i,j,bi,bj) = 0. _d 0
           pS_ad(i,j,bi,bj) = 0. _d 0
           pC_ad(i,j,bi,bj) = 0. _d 0
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ELSE
C     Initialise AD fields to zero. They will not have any effect on
C     the solution, because we fake the AD code of cg2d.
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
          aW2d_ad(i,j,bi,bj) = 0. _d 0
          aS2d_ad(i,j,bi,bj) = 0. _d 0
          aC2d_ad(i,j,bi,bj) = 0. _d 0
          pW_ad  (i,j,bi,bj) = 0. _d 0
          pS_ad  (i,j,bi,bj) = 0. _d 0
          pC_ad  (i,j,bi,bj) = 0. _d 0
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */
#endif /* ALLOW_AUTODIFF_TAMC */

      RETURN
      END
