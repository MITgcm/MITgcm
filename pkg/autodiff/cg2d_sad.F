#include "AUTODIFF_OPTIONS.h"
#ifdef "ALLOW_CTRL"
# include "CTRL_OPTIONS.h"
#endif

C--   File cg2d_sad.F: Code for hand written adjoint of cg2d
C--    Contents
C--   CG2D_SAD        - computes the adjoint of cg2d
C--   CG2D_STORE      - saves input field to or restores from a common block
C--   CG2D_STORE_AD   - empty AD-version of CG2D_STORE

CBOP
C     !ROUTINE: CG2D_SAD
C     !INTERFACE:
      SUBROUTINE CG2D_SAD(
     U                    cg2d_b_ad, cg2d_x_ad,
     U                    numIters, nIterMin,
     I                    myThid )
C     !DESCRIPTION: \bv
C     *==========================================================*
C     | SUBROUTINE CG2D_SAD
C     | o Self-ADjoint version of CG2D, the two-dimensional
C     |   grid problem conjugate-gradient inverter.
C     *==========================================================*
C     | This routine is called from solve_for_pressure_ad that
C     | is generated by TAF/TAMC. We want a self-adjoint cg2d
C     | to avoid too many complications, so we provide flow
C     | directives in cg2d.flow and fake it here.
C     | This routine calls cg2d with reversed order of argumgent
C     | cg2d_x_ad and cg2d_b_ad, and sets dependendcies to zero
C     | that a non-self-adjoint cg2d would have produced.
C     *==========================================================*
C     \ev

C     !USES:
      IMPLICIT NONE
C     === Global data ===
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#include "CG2D.h"
#include "AUTODIFF_PARAMS.h"

C     !INPUT/OUTPUT PARAMETERS:
C     === Routine arguments ===
C     cg2d_b_ad :: Adjoint of source term
C     cg2d_x_ad :: Adjoint of the solution
C     firstResidual :: the initial residual before any iterations
C     minResidualSq :: the lowest residual reached (squared)
C     lastResidual  :: the actual residual reached
C     numIters  :: Inp: the maximum number of iterations allowed
C                  Out: the actual number of iterations used
C     nIterMin  :: Inp: decide to store (if >=0) or not (if <0) lowest res. sol.
C                  Out: iteration number corresponding to lowest residual
C     myThid    :: Thread on which I am working.
      _RL  cg2d_b_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL  cg2d_x_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
c     _RL  firstResidual, minResidualSq, lastResidual
      INTEGER numIters
      INTEGER nIterMin
      INTEGER myThid

#ifdef ALLOW_AUTODIFF_TAMC
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
C     directly imported from TAF-generated code, make sure that they are
C     consistent with what is found in S/R update_cg2d_ad
      _RL aW2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aS2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL aC2d_ad(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pW_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pS_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL pC_ad  (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      COMMON /CG2D_I_R_AD/
     &     aW2d_ad, aS2d_ad, aC2d_ad, pW_ad, pS_ad, pC_ad

C     cg2d_x    :: The solution (only input)
C     cg2dTmp   :: Temporary storage for cg2d_b_ad
      _RL cg2d_x (1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      _RL cg2dTmp(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */

C     !LOCAL VARIABLES:
C     === Local variables ===
C     bi,bj  :: tile indices
C     i,j    :: Loop counters
      INTEGER i,j,bi,bj
      _RL  firstResidual, minResidualSq, lastResidual
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      _RL  recip_cg2dNorm
#endif
CEOP

C--   mark output of cg2d as being called from here
      IF ( debugLevel .GE. debLevZero ) THEN
       _BEGIN_MASTER( myThid )
       WRITE(standardmessageunit,'(A)')
     &      ' Calling cg2d from S/R CG2D_SAD'
       _END_MASTER( myThid )
      ENDIF

#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      recip_cg2dNorm = 1.0 _d 0
      IF ( cg2dNorm .NE. 0. _d 0 ) THEN
       recip_cg2dNorm = 1./cg2dNorm
      ENDIF

      IF ( cg2dFullAdjoint ) THEN
C     Save input cg2d_b_ad, not sure if this is necessary.
       DO bj = myByLo(myThid), myByHi(myThid)
        DO bi = myBxLo(myThid), myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
           cg2dTmp(i,j,bi,bj) = cg2d_b_ad(i,j,bi,bj)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */

#ifdef ALLOW_SRCG
      IF ( useSRCGSolver ) THEN
C--   Call the single reduce CG solver
       CALL CG2D_SR(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ELSE
#else
      IF (.TRUE.) THEN
#endif /* ALLOW_SRCG */
C--   Call the default CG solver
       CALL CG2D(
     U      cg2d_x_ad, cg2d_b_ad,
     O      firstResidual, minResidualSq, lastResidual,
     U      numIters, nIterMin,
     I      myThid )
      ENDIF

#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      IF ( cg2dFullAdjoint ) THEN
       CALL CG2D_STORE( cg2d_x, .FALSE., myThid )
C     Compute derivative of coefficient matrix.
       _EXCH_XY_RL( cg2d_b_ad, myThid )
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=2-OLy,sNy+OLy-1
          DO i=2-OLx,sNx+OLx-1
           aC2d_ad(i,j,bi,bj)   = aC2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i,  j,bi,bj) =  aW2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i-1,j,bi,bj)
     &          * recip_cg2dNorm
           aW2d_ad(i+1,j,bi,bj) =  aW2d_ad(i+1,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i+1,j,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j,  bi,bj) = aS2d_ad(i,j,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j-1,bi,bj)
     &          * recip_cg2dNorm
           aS2d_ad(i,j+1,bi,bj) = aS2d_ad(i,j+1,bi,bj)
     &          - cg2d_b_ad(i,j,bi,bj) * cg2d_x(i,j+1,bi,bj)
     &          * recip_cg2dNorm
C     The sensitivities of preconditioner are something like
C          pC_ad = pC_ad + cg2d_z_ad * cg2d_r
C     and similar (cg2d_z = preconditioner * cg2d_r). That is, when the
C     solver has converged, cg2d_r -> 0 and pC_ad -> 0,unless cg2d_z_ad
C     is large, which would mean an instability. Therefore we set the
C     preconditioner adjoint to zero. This also reflect the fact, that
C     in an ideal world, the preconditioner does not have any effect on
C     the solution, but only on the rate of convergence.
           pW_ad  (i,j,bi,bj) = 0. _d 0
           pS_ad  (i,j,bi,bj) = 0. _d 0
           pC_ad  (i,j,bi,bj) = 0. _d 0
CML why do we need this? Isnt that counting things twice?
           cg2d_b_ad(i,j,bi,bj) = cg2d_b_ad(i,j,bi,bj)
     &          + cg2dTmp(i,j,bi,bj)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ELSE
C     Initialise AD fields to zero. They will not have any effect on
C     the solution, because we fake the AD code of cg2d.
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
          aW2d_ad(i,j,bi,bj) = 0. _d 0
          aS2d_ad(i,j,bi,bj) = 0. _d 0
          aC2d_ad(i,j,bi,bj) = 0. _d 0
          pW_ad  (i,j,bi,bj) = 0. _d 0
          pS_ad  (i,j,bi,bj) = 0. _d 0
          pC_ad  (i,j,bi,bj) = 0. _d 0
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */

      DO bj=myByLo(myThid),myByHi(myThid)
       DO bi=myBxLo(myThid),myBxHi(myThid)
        DO j=1-OLy,sNy+OLy
         DO i=1-OLx,sNx+OLx
C     cg2d_x_ad is reset to zero, because we assume that the solution of
C     the self-adjoint solver does not depend in the intial conditions
C     so that no sensitivities should be passed back to the caller.
          cg2d_x_ad(i,j,bi,bj) = 0. _d 0
         ENDDO
        ENDDO
       ENDDO
      ENDDO
#endif /* ALLOW_AUTODIFF_TAMC */

      RETURN
      END

C--------1---------2---------3---------4---------5---------6---------7--

CBOP
C     !ROUTINE: CG2D_STORE
C     !INTERFACE:
      SUBROUTINE CG2D_STORE(
     U                      cg2d_x,
     I                      doStore,
     I                      myThid )
C     !DESCRIPTION: \bv
C     *==========================================================*
C     | SUBROUTINE CG2D_STORE
C     | o Hand written tape routine
C     *==========================================================*
C     | This routine is called from solve_for_pressure to
C     | to force TAF to store cg2d_x
C     *==========================================================*
C     \ev

C     !USES:
      IMPLICIT NONE
C     === Global data ===
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#include "AUTODIFF_PARAMS.h"
#ifdef ALLOW_AUTODIFF_TAMC
# include "tamc.h"
#endif

C     !INPUT/OUTPUT PARAMETERS:
C     === Routine arguments ===
C     cg2d_x    :: The solution to be stored and restored
C     doStore   :: Store or restore based on the logical
C     myThid    :: Thread on which I am working.
      _RL  cg2d_x(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy)
      LOGICAL doStore
      INTEGER myThid

#ifdef ALLOW_AUTODIFF_TAMC
#if ( defined NONLIN_FRSURF || defined ALLOW_DEPTH_CONTROL )
      _RL cg2d_tape(1-OLx:sNx+OLx,1-OLy:sNy+OLy,nSx,nSy,nchklev_1)
      COMMON /CG2D_TAPE_RL/ cg2d_tape

C     !LOCAL VARIABLES:
C     === Local variables ===
C     bi,bj  :: tile indices
C     i,j    :: Loop counters
      INTEGER i,j,bi,bj
CEOP

C--   mark output of cg2d as being called from here
      IF ( debugLevel .GE. debLevZero ) THEN
       _BEGIN_MASTER( myThid )
       WRITE(standardmessageunit,'(A,L)')
     &      ' Calling CG2D_STORE with doStore = ', doStore
       WRITE(standardmessageunit,'(A,I4)')
     &      ' Calling CG2D_STORE with ikey_dynamics = ', ikey_dynamics
       _END_MASTER( myThid )
      ENDIF

      IF ( doStore ) THEN
C     Save input cg2d_x to local common block
       DO bj = myByLo(myThid), myByHi(myThid)
        DO bi = myBxLo(myThid), myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
           cg2d_tape(i,j,bi,bj,ikey_dynamics) = cg2d_x(i,j,bi,bj)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ELSE
C     Restore output cg2d_x from local common block
       DO bj = myByLo(myThid), myByHi(myThid)
        DO bi = myBxLo(myThid), myBxHi(myThid)
         DO j=1-OLy,sNy+OLy
          DO i=1-OLx,sNx+OLx
           cg2d_x(i,j,bi,bj) = cg2d_tape(i,j,bi,bj,ikey_dynamics)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif /* NONLIN_FRSURF or ALLOW_DEPTH_CONTROL */
#endif /* ALLOW_AUTODIFF_TAMC */

      RETURN
      END

C--------1---------2---------3---------4---------5---------6---------7--

CBOP
C     !ROUTINE: CG2D_STORE_AD
C     !INTERFACE:
      SUBROUTINE CG2D_STORE_AD(
     U                      cg2d_x_ad,
     I                      doStore,
     I                      myThid )

C     !DESCRIPTION: \bv
C     *==========================================================*
C     | SUBROUTINE CG2D_STORE
C     | o Fake AD routine for CG2D_STORE, does not do anything
C     |   and should never be called
C     *==========================================================*
C     \ev

C     !INPUT/OUTPUT PARAMETERS:
C     === Routine arguments ===
C     cg2d_x    :: The solution to be stored and restored
C     doStore   :: Store or restore based on the logical
C     myThid    :: Thread on which I am working.
      _RL  cg2d_x_ad(1)
      LOGICAL doStore
      INTEGER myThid
CEOP
#ifdef ALLOW_AUTODIFF_TAMC
C     Do nothing
      STOP 'S/R CG2D_STORE_AD should never be called'
#endif /* ALLOW_AUTODIFF_TAMC */

      RETURN
      END
