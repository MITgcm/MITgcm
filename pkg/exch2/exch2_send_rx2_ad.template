C $Header: /u/gcmpack/MITgcm/pkg/exch2/Attic/exch2_send_rx2_ad.template,v 1.4 2008/08/05 18:31:56 cnh Exp $
C $Name:  $

#include "CPP_EEOPTIONS.h"
#include "W2_OPTIONS.h"

      SUBROUTINE EXCH2_SEND_RX2_AD(
     I       tIlo1, tIhi1, tIlo2, tIhi2, tiStride,
     I       tJlo1, tJhi1, tJlo2, tJhi2, tjStride,
     I       tKlo, tKhi, tkStride,
     I       thisTile, nN, oIs1, oJs1, oIs2, oJs2,
     O       e2Bufr1_RX, e2Bufr2_RX,
     I       e2BufrRecSize,
     I       array1,
     I       i1Lo, i1Hi, j1Lo, j1Hi, k1Lo, k1Hi,
     I       array2,
     I       i2Lo, i2Hi, j2Lo, j2Hi, k2Lo, k2Hi,
     O       e2_msgHandle1,
     O       e2_msgHandle2,
     I       commSetting, withSigns, myThid )

C     Vector exchange with bufr1 along +i axis in target tile and
C     bufr2 along +j axis in target tile.

      IMPLICIT NONE

#include "SIZE.h"
#include "EEPARAMS.h"
#include "EESUPPORT.h"
#include "W2_EXCH2_TOPOLOGY.h"

C     === Routine arguments ===
      INTEGER tIlo1, tIhi1, tIlo2, tIhi2, tiStride
      INTEGER tJlo1, tJhi1, tJlo2, tJhi2, tjStride
      INTEGER tKLo, tKHi, tkStride
      INTEGER i1Lo, i1Hi, j1Lo, j1Hi, k1Lo, k1Hi
      INTEGER i2Lo, i2Hi, j2Lo, j2Hi, k2Lo, k2Hi
      INTEGER thisTile, nN
      INTEGER oIs1, oJs1, oIs2, oJs2
      INTEGER e2BufrRecSize
      _RX     e2Bufr1_RX( e2BufrRecSize )
      _RX     e2Bufr2_RX( e2BufrRecSize )
      _RX     array1(i1Lo:i1Hi,j1Lo:j1Hi,k1Lo:k1Hi)
      _RX     array2(i2Lo:i2Hi,j2Lo:j2Hi,k2Lo:k2Hi)
      INTEGER e2_msgHandle1(1)
      INTEGER e2_msgHandle2(1)
      INTEGER myThid
      CHARACTER commSetting
      LOGICAL   withSigns

C     == Local variables ==
C     itl, jtl, ktl  :: Loop counters
C                    :: itl etc... target local
C                    :: itc etc... target canonical
C                    :: isl etc... source local
C                    :: isc etc... source canonical
      INTEGER itl, jtl, ktl
      INTEGER itc, jtc
      INTEGER isc, jsc
      INTEGER isl, jsl
C     tt         :: Target tile
C     itb, jtb   :: Target local to canonical offsets
C
      INTEGER  tt
      INTEGER itb, jtb
      INTEGER isb, jsb
      INTEGER pi(2), pj(2)
      _RX     sa1, sa2, val1, val2
      INTEGER iBufr1, iBufr2

C     MPI setup
#ifdef ALLOW_USE_MPI
      INTEGER nri1, nrj1, nrk1
      INTEGER nri2, nrj2, nrk2
      INTEGER theTag1, theTag2, theType
      INTEGER sProc, tProc
      INTEGER mpiStatus(MPI_STATUS_SIZE), mpiRc
#endif
      CHARACTER*(MAX_LEN_MBUF) messageBuffer

      IF     ( commSetting .EQ. 'P' ) THEN
C      Need to check that buffer synchronisation token is decremented
C      before filling buffer. This is needed for parallel processing
C      shared memory modes only.
      ENDIF

      tt=exch2_neighbourId(nN, thisTile )
      itb=exch2_tBasex(tt)
      jtb=exch2_tBasey(tt)
      isb=exch2_tBasex(thisTile)
      jsb=exch2_tBasey(thisTile)
      pi(1)=exch2_pij(1,nN,thisTile)
      pi(2)=exch2_pij(2,nN,thisTile)
      pj(1)=exch2_pij(3,nN,thisTile)
      pj(2)=exch2_pij(4,nN,thisTile)

C     Do data transport depending on communication mechanism between source and target tile
      IF     ( commSetting .EQ. 'P' ) THEN
C      Need to set data ready assertion (increment buffer
C      synchronisation token) for multithreaded mode, for now do
C      nothing i.e. assume only one thread per process.
      ELSEIF ( commSetting .EQ. 'M' ) THEN
#ifdef ALLOW_USE_MPI
C      Setup MPI stuff here
       theTag1 =  (thisTile-1)*MAX_NEIGHBOURS*2 + nN-1
       theTag2 =  (thisTile-1)*MAX_NEIGHBOURS*2 + MAX_NEIGHBOURS + nN-1
       tProc = exch2_tProc(tt)-1
       sProc = exch2_tProc(thisTile)-1
       theType = MPI_REAL8
       nri1 = (tIhi1-tIlo1+1)/tiStride
       nrj1 = (tJhi1-tJlo1+1)/tjStride
       nrk1 = (tKhi-tKlo+1)/tkStride
       iBufr1 = nri1*nrj1*nrk1
       nri2 = (tIhi2-tIlo2+1)/tiStride
       nrj2 = (tJhi2-tJlo2+1)/tjStride
       nrk2 = (tKhi-tKlo+1)/tkStride
       iBufr2 = nri2*nrj2*nrk2
#ifdef W2_E2_DEBUG_ON
       WRITE(messageBuffer,'(A,I4,A,I4,A)')
     &                     ' SEND FROM TILE=', thisTile,
     &                     ' (proc = ',sProc,')'
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4,A,I4,A)') '        TO TILE=', tt,
     &                                   ' (proc = ',tProc,')'
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I10)') '            TAG1=', theTag1
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4)') '            NEL1=', iBufr1
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I10)') '            TAG2=', theTag2
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
       WRITE(messageBuffer,'(A,I4)') '            NEL2=', iBufr2
       CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_RIGHT,
     I      myThid)
#endif /* W2_E2_DEBUG_ON */
       CALL MPI_Recv( e2Bufr1_RX, iBufr1, theType,
     I                 tProc, theTag1, MPI_COMM_MODEL,
     O                 mpiStatus, mpiRc )
       CALL MPI_Recv( e2Bufr2_RX, iBufr2, theType,
     I                 tProc, theTag2, MPI_COMM_MODEL,
     O                 mpiStatus, mpiRc )
C      Store MPI_Wait token in messageHandle.
#endif /* ALLOW_USE_MPI */
      ELSE
       STOP 'EXCH2_SEND_RX2_AD:: commSetting VALUE IS INVALID'
      ENDIF

C     Extract into bufr1 (target i-index array)
C     if pi(1) is  1 then +i in target <=> +i in source so bufr1 should get +array1
C     if pi(1) is -1 then +i in target <=> -i in source so bufr1 should get -array1
C     if pj(1) is  1 then +i in target <=> +j in source so bufr1 should get +array2
C     if pj(1) is -1 then +i in target <=> -j in source so bufr1 should get -array2
      sa1 = pi(1)
      sa2 = pj(1)
      IF ( .NOT. withSigns ) THEN
       sa1 = ABS(sa1)
       sa2 = ABS(sa2)
      ENDIF
      iBufr1=0
#ifdef W2_E2_DEBUG_ON
      WRITE(messageBuffer,'(A,I4,A,I4)')
     &     'EXCH2_SEND_RX2_AD sourceTile= ',
     &                                   thisTile,
     &                                   ' targetTile= ',tt
      CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_BOTH,
     I      myThid)
#endif /* W2_E2_DEBUG_ON */
      DO ktl=tKlo,tKhi,tkStride
       DO jtl=tJlo1, tJhi1, tjStride
        DO itl=tIlo1, tIhi1, tiStride
         iBufr1=iBufr1+1
         itc=itl+itb
         jtc=jtl+jtb
         isc=pi(1)*itc+pi(2)*jtc+oIs1
         jsc=pj(1)*itc+pj(2)*jtc+oJs1
         isl=isc-isb
         jsl=jsc-jsb
         val1 = e2Bufr1_RX(iBufr1)
         array1(isl,jsl,ktl) = array1(isl,jsl,ktl) + sa1*val1
         array2(isl,jsl,ktl) = array2(isl,jsl,ktl) + sa2*val1
        ENDDO
       ENDDO
      ENDDO

C     Extract values into bufr2
C     if pi(2) is  1 then +j in target <=> +i in source so bufr1 should get +array1
C     if pi(2) is -1 then +j in target <=> -i in source so bufr1 should get -array1
C     if pj(2) is  1 then +j in target <=> +j in source so bufr1 should get +array2
C     if pj(2) is -1 then +j in target <=> -j in source so bufr1 should get -array2
      sa1 = pi(2)
      sa2 = pj(2)
      IF ( .NOT. withSigns ) THEN
       sa1 = ABS(sa1)
       sa2 = ABS(sa2)
      ENDIF
      iBufr2=0
#ifdef W2_E2_DEBUG_ON
      WRITE(messageBuffer,'(A,I4,A,I4)')
     &     'EXCH2_SEND_RX2_AD sourceTile= ',
     &                                   thisTile,
     &                                   ' targetTile= ',tt
      CALL PRINT_MESSAGE(messageBuffer,
     I      standardMessageUnit,SQUEEZE_BOTH,
     I      myThid)
#endif /* W2_E2_DEBUG_ON */
      DO ktl=tKlo,tKhi,tkStride
       DO jtl=tJlo2, tJhi2, tjStride
        DO itl=tIlo2, tIhi2, tiStride
         iBufr2=iBufr2+1
         itc=itl+itb
         jtc=jtl+jtb
         isc=pi(1)*itc+pi(2)*jtc+oIs2
         jsc=pj(1)*itc+pj(2)*jtc+oJs2
         isl=isc-isb
         jsl=jsc-jsb
         val2 = e2Bufr2_RX(iBufr2)
         array1(isl,jsl,ktl) = array1(isl,jsl,ktl) + sa1*val2
         array2(isl,jsl,ktl) = array2(isl,jsl,ktl) + sa2*val2
        ENDDO
       ENDDO
      ENDDO

      RETURN
      END

C---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|

CEH3 ;;; Local Variables: ***
CEH3 ;;; mode:fortran ***
CEH3 ;;; End: ***
