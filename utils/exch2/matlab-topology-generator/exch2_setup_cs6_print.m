function exch2_setup_cs6_print( domain, tile, tnx, tny, ntile)
% Write out tile attributes in a structured format
% Use fixed format Fortran for now
% 1 - many routines in one big file
% 2 - many routines in many files
outmode=1;
%outmode=2;
outdir='./';

% $Header: /u/gcmpack/MITgcm/utils/exch2/matlab-topology-generator/Attic/exch2_setup_cs6_print.m,v 1.2 2007/03/19 20:34:26 jmc Exp $
% $Name:  $

% Output unit
fnam=sprintf('%s%s',outdir,'w2_e2setup.F');
fnamh=sprintf('%s%s',outdir,'W2_EXCH2_TOPOLOGY.h');
fout=fopen(fnam,'w');
fouth=fopen(fnamh,'w');

% Declare data structures ti hold the information

domain_nxt=0;
for i=1:length(domain)
  domain_nxt = domain_nxt+(domain(i).dnx/tnx)
end
domain_nyt = (max([domain(:).dny])/tny)

% Figure out maximum number of neighbors any tile has
nNeighbors=0;
for j=1:length(tile)
 myNeighborCount=sum(tile(j).nW+tile(j).nN+tile(j).nE+tile(j).nS);
 nNeighbors=max(nNeighbors,myNeighborCount);
end

% Create header file
fprintf(fouth,'C      Tiling topology data structures header file\n');
fprintf(fouth,'C      *** THIS FILE IS AUTOMATICALLY GENERATED ***\n');
fprintf(fouth,'C      NTILES            :: Number of tiles in this topology \n');
fprintf(fouth,'C      MAX_NEIGHBOURS    :: Maximum number of neighbours any tile has.\n');
fprintf(fouth,'C      exch2_domain_nxt  :: Total domain length in tiles. \n');
fprintf(fouth,'C      exch2_domain_nyt  :: Maximum domain height in tiles. \n');
fprintf(fouth,'C      exch2_tnx         :: Size in X for each tile.                  \n');
fprintf(fouth,'C      exch2_tny         :: Size in Y for each tile.                  \n');
fprintf(fouth,'C      exch2_tbasex      :: Tile offset in X within its sub-domain (cube face)\n');
fprintf(fouth,'C      exch2_tbasey      :: Tile offset in Y within its sub-domain (cube face)\n');
fprintf(fouth,'C      exch2_tglobalxlo  :: Tile base X index within global index space.\n');
fprintf(fouth,'C      exch2_tglobalylo  :: Tile base Y index within global index space.\n');
fprintf(fouth,'C      exch2_isWedge     :: 0 if West not at domain edge, 1 if it is.   \n');
fprintf(fouth,'C      exch2_isNedge     :: 0 if North not at domain edge, 1 if it is.   \n');
fprintf(fouth,'C      exch2_isEedge     :: 0 if East not at domain edge, 1 if it is.   \n');
fprintf(fouth,'C      exch2_isSedge     :: 0 if South not at domain edge, 1 if it is.   \n');
fprintf(fouth,'C      exch2_myFace      :: Cube face number used for I/O.               \n');
fprintf(fouth,'C      exch2_nNeighbours :: Tile neighbour entries count.               \n');
fprintf(fouth,'C      exch2_tProc       :: Rank of process owning tile                 \n');
fprintf(fouth,'C                        :: (filled at run time).                       \n');
fprintf(fouth,'C      exch2_neighbourId :: Tile number for each neighbour entry.        \n');
fprintf(fouth,'C      exch2_opposingSend_record :: Record for entry in target tile send \n');
fprintf(fouth,'C                                :: list that has this tile and face     \n');
fprintf(fouth,'C                                :: as its target.                       \n');
fprintf(fouth,'C      exch2_pi          :: X index row of target to source permutation \n');
fprintf(fouth,'C                        :: matrix for each neighbour entry.            \n');
fprintf(fouth,'C      exch2_pj          :: Y index row of target to source permutation \n');
fprintf(fouth,'C                        :: matrix for each neighbour entry.            \n');
fprintf(fouth,'C      exch2_oi          :: X index element of target to source \n');
fprintf(fouth,'C                        :: offset vector for cell-centered quantities  \n');
fprintf(fouth,'C                        :: of each neighbor entry.                     \n');
fprintf(fouth,'C      exch2_oj          :: Y index element of target to source \n');
fprintf(fouth,'C                        :: offset vector for cell-centered quantities  \n');
fprintf(fouth,'C                        :: of each neighbor entry.                     \n');
fprintf(fouth,'C      exch2_oi_f        :: X index element of target to source \n');
fprintf(fouth,'C                        :: offset vector for face quantities           \n');
fprintf(fouth,'C                        :: of each neighbor entry.                     \n');
fprintf(fouth,'C      exch2_oj_f        :: Y index element of target to source \n');
fprintf(fouth,'C                        :: offset vector for face quantities           \n');
fprintf(fouth,'C                        :: of each neighbor entry.                     \n');
fprintf(fouth,'       INTEGER NTILES\n');
fprintf(fouth,'       INTEGER MAX_NEIGHBOURS\n');
fprintf(fouth,'       INTEGER exch2_domain_nyt\n');
fprintf(fouth,'       INTEGER exch2_domain_nxt\n');
fprintf(fouth,'       PARAMETER ( NTILES = %d)\n',length(tile));
fprintf(fouth,'       PARAMETER ( MAX_NEIGHBOURS = %d)\n',nNeighbors);
fprintf(fouth,'       PARAMETER ( exch2_domain_nxt=%d)\n',domain_nxt);
fprintf(fouth,'       PARAMETER ( exch2_domain_nyt=%d)\n',domain_nyt);
fprintf(fouth,'       INTEGER exch2_tnx(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_tny(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_tbasex(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_tbasey(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_txglobalo(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_tyglobalo(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_isWedge(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_isNedge(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_isEedge(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_isSedge(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_myFace(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_mydnx(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_mydny(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_nNeighbours(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_tProc(NTILES)\n');
fprintf(fouth,'       INTEGER exch2_neighbourId(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_opposingSend_record(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_pi(2,MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_pj(2,MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_oi(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_oj(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_oi_f(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_oj_f(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'                                                  \n');
fprintf(fouth,'                                                  \n');
fprintf(fouth,'C      Exchange execution loop data structures    \n');
fprintf(fouth,'       INTEGER exch2_itlo_c(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_ithi_c(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_jtlo_c(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'       INTEGER exch2_jthi_c(MAX_NEIGHBOURS,NTILES)\n');
fprintf(fouth,'                                                  \n');
fprintf(fouth,'       COMMON /W2_EXCH2_TOPO_I/                   \n');
fprintf(fouth,'     &        exch2_tnx, exch2_tny,               \n');
fprintf(fouth,'     &        exch2_tbasex,exch2_tbasey,          \n');
fprintf(fouth,'     &        exch2_txglobalo,exch2_tyglobalo,    \n');
fprintf(fouth,'     &        exch2_isWedge, exch2_isNedge,       \n');
fprintf(fouth,'     &        exch2_isEedge, exch2_isSedge,       \n');
fprintf(fouth,'     &        exch2_myFace, exch2_mydnx, exch2_mydny, \n');
fprintf(fouth,'     &        exch2_nNeighbours,exch2_neighbourId,\n');
fprintf(fouth,'     &        exch2_opposingSend_record,          \n');
fprintf(fouth,'     &        exch2_tProc,                        \n');
fprintf(fouth,'     &        exch2_pi,exch2_pj,                  \n');
fprintf(fouth,'     &        exch2_oi,exch2_oj,                  \n');
fprintf(fouth,'     &        exch2_oi_f,exch2_oj_f               \n');
fprintf(fouth,'                                                  \n');
fprintf(fouth,'       COMMON /W2_EXCH2_HALO_SPEC/                \n');
fprintf(fouth,'     &        exch2_itlo_c, exch2_ithi_c,         \n');
fprintf(fouth,'     &        exch2_jtlo_c, exch2_jthi_c          \n');

fprintf(fout,'       SUBROUTINE W2_E2SETUP                       \n');
fprintf(fouth,'C     *** THIS FILE IS AUTOMATICALLY GENERATED ***\n');
fprintf(fout,'                                                  \n');
fprintf(fout,'C      Tile toplogy settings data structures      \n');
fprintf(fout,'#include "W2_EXCH2_TOPOLOGY.h"\n');
fprintf(fout,'                                                  \n');

% Settings
fprintf(fout,'C      Tile settings table                        \n');
for j=1:length(tile)
fprintf(fout,'       CALL W2_E2SETUP_%d\n',j);
end
fprintf(fout,'       RETURN\n');
fprintf(fout,'       END\n');
if outmode == 2
fclose(fout);
end

for j=1:length(tile)
if outmode == 2
fnam=sprintf('w2_e2setup_%d.F',j);
fnamf=sprintf('%s%s',outdir,fnam);
fout=fopen(fnamf,'w');
end
fprintf(fout,'       SUBROUTINE W2_E2SETUP_%d\n',j);
fprintf(fout,'C      Topology for tile %d\n',j);
fprintf(fout,'#include "W2_EXCH2_TOPOLOGY.h"\n');
fprintf(fout,'       exch2_tnx(%d)=%d\n',j,tile(j).tnx);
fprintf(fout,'       exch2_tny(%d)=%d\n',j,tile(j).tny);
fprintf(fout,'       exch2_tbasex(%d)=%d\n',j,tile(j).tbasex);
fprintf(fout,'       exch2_tbasey(%d)=%d\n',j,tile(j).tbasey);
fprintf(fout,'       exch2_txglobalo(%d)=%d\n',j,tile(j).txgloballo);
fprintf(fout,'       exch2_tyglobalo(%d)=%d\n',j,tile(j).tygloballo);
fprintf(fout,'       exch2_isWedge(%d)=%d\n',j,tile(j).isWedge);
fprintf(fout,'       exch2_isNedge(%d)=%d\n',j,tile(j).isNedge);
fprintf(fout,'       exch2_isEedge(%d)=%d\n',j,tile(j).isEedge);
fprintf(fout,'       exch2_isSedge(%d)=%d\n',j,tile(j).isSedge);
fprintf(fout,'       exch2_myFace(%d)=%d\n',j,tile(j).mydomain);
fprintf(fout,'       exch2_mydnx(%d)=%d\n',j,domain(tile(j).mydomain).dnx);
fprintf(fout,'       exch2_mydny(%d)=%d\n',j,domain(tile(j).mydomain).dny);
myNeighborCount=sum(tile(j).nW+tile(j).nN+tile(j).nE+tile(j).nS);
fprintf(fout,'       exch2_nNeighbours(%d)=%d\n',j,myNeighborCount);
in=0;

for n=1:tile(j).nN
 fprintf(fout,'\n');
 in=in+1;
 fprintf(fout,'       exch2_neighbourId(%d,%d)=%d\n',in,j,tile(j).nTile(n));
 fprintf(fout,'       exch2_pi(1,%d,%d)=%d\n',in,j,tile(j).n_pi(n,1));
 fprintf(fout,'       exch2_pi(2,%d,%d)=%d\n',in,j,tile(j).n_pi(n,2));
 fprintf(fout,'       exch2_pj(1,%d,%d)=%d\n',in,j,tile(j).n_pj(n,1));
 fprintf(fout,'       exch2_pj(2,%d,%d)=%d\n',in,j,tile(j).n_pj(n,2));
 fprintf(fout,'       exch2_oi(%d,%d)=%d\n',in,j,tile(j).n_oi(n));
 fprintf(fout,'       exch2_oi_f(%d,%d)=%d\n',in,j,tile(j).n_oi_f(n));
 fprintf(fout,'       exch2_oj(%d,%d)=%d\n',in,j,tile(j).n_oj(n));
 fprintf(fout,'       exch2_oj_f(%d,%d)=%d\n',in,j,tile(j).n_oj_f(n));
 fprintf(fout,'       exch2_itlo_c(%d,%d)=%d\n',in,j,tile(j).n_itlo_l(n));
 fprintf(fout,'       exch2_ithi_c(%d,%d)=%d\n',in,j,tile(j).n_ithi_l(n));
 fprintf(fout,'       exch2_jtlo_c(%d,%d)=%d\n',in,j,tile(j).n_jtlo_l(n));
 fprintf(fout,'       exch2_jthi_c(%d,%d)=%d\n',in,j,tile(j).n_jthi_l(n));
 % Find corresponding target tile send entry from which I will receive
 % Need to know the send tiles edge, since same tile could send to this tile
 % from multiple edges. However there is only one send per remote tile for
 % any single edge.
 targetTile=tile(j).nTile(n);
 if tile(j).n_pi(n,:) == [0 -1] & tile(j).n_pj(n,:) == [ 1 0]
  % Send wil be from targets west edge, find this tile in targets north edge list
  for k=1:tile(targetTile).nW
   if tile(targetTile).wTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+tile(targetTile).nS+tile(targetTile).nE+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 elseif tile(j).n_pi(n,:) == [1 0] & tile(j).n_pj(n,:) == [0 1]
  % Send wil be from targets south edge, find this tile in targets south edge list
  for k=1:tile(targetTile).nS
   if tile(targetTile).sTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+tile(targetTile).nN+tile(targetTile).nE+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 else
  fprintf(fout,'ERROR MISSING CASE IN GENERATING CODE\n');
 end
end

for n=1:tile(j).nS
 fprintf(fout,'\n');
 in=in+1;
 fprintf(fout,'       exch2_neighbourId(%d,%d)=%d\n',in,j,tile(j).sTile(n));
 fprintf(fout,'       exch2_pi(1,%d,%d)=%d\n',in,j,tile(j).s_pi(n,1));
 fprintf(fout,'       exch2_pi(2,%d,%d)=%d\n',in,j,tile(j).s_pi(n,2));
 fprintf(fout,'       exch2_pj(1,%d,%d)=%d\n',in,j,tile(j).s_pj(n,1));
 fprintf(fout,'       exch2_pj(2,%d,%d)=%d\n',in,j,tile(j).s_pj(n,2));
 fprintf(fout,'       exch2_oi(%d,%d)=%d\n',in,j,tile(j).s_oi(n));
 fprintf(fout,'       exch2_oi_f(%d,%d)=%d\n',in,j,tile(j).s_oi_f(n));
 fprintf(fout,'       exch2_oj(%d,%d)=%d\n',in,j,tile(j).s_oj(n));
 fprintf(fout,'       exch2_oj_f(%d,%d)=%d\n',in,j,tile(j).s_oj_f(n));
 fprintf(fout,'       exch2_itlo_c(%d,%d)=%d\n',in,j,tile(j).s_itlo_l(n));
 fprintf(fout,'       exch2_ithi_c(%d,%d)=%d\n',in,j,tile(j).s_ithi_l(n));
 fprintf(fout,'       exch2_jtlo_c(%d,%d)=%d\n',in,j,tile(j).s_jtlo_l(n));
 fprintf(fout,'       exch2_jthi_c(%d,%d)=%d\n',in,j,tile(j).s_jthi_l(n));
 % Find corresponding target tile send entry from which I will receive
 % Need to know the send tiles edge, since same tile could send to this tile
 % from multiple edges. However there is only one send per remote tile for
 % any single edge.
 targetTile=tile(j).sTile(n);
 if tile(j).s_pi(n,:) == [0 -1] & tile(j).s_pj(n,:) == [ 1 0]
  % Opposing send wil be from targets east edge, find this tile in targets east edge list
  for k=1:tile(targetTile).nE
   if tile(targetTile).eTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+tile(targetTile).nN+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+tile(targetTile).nS+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 elseif tile(j).s_pi(n,:) == [1 0] & tile(j).s_pj(n,:) == [0 1]
  % Opposing send wil be from targets north edge, find this tile in targets north edge list
  for k=1:tile(targetTile).nN
   if tile(targetTile).nTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 else
  fprintf(fout,'ERROR MISSING CASE IN GENERATING CODE\n');
 end
end

for n=1:tile(j).nE
 fprintf(fout,'\n');
 in=in+1;
 fprintf(fout,'       exch2_neighbourId(%d,%d)=%d\n',in,j,tile(j).eTile(n));
 fprintf(fout,'       exch2_pi(1,%d,%d)=%d\n',in,j,tile(j).e_pi(n,1));
 fprintf(fout,'       exch2_pi(2,%d,%d)=%d\n',in,j,tile(j).e_pi(n,2));
 fprintf(fout,'       exch2_pj(1,%d,%d)=%d\n',in,j,tile(j).e_pj(n,1));
 fprintf(fout,'       exch2_pj(2,%d,%d)=%d\n',in,j,tile(j).e_pj(n,2));
 fprintf(fout,'       exch2_oi(%d,%d)=%d\n',in,j,tile(j).e_oi(n));
 fprintf(fout,'       exch2_oi_f(%d,%d)=%d\n',in,j,tile(j).e_oi_f(n));
 fprintf(fout,'       exch2_oj(%d,%d)=%d\n',in,j,tile(j).e_oj(n));
 fprintf(fout,'       exch2_oj_f(%d,%d)=%d\n',in,j,tile(j).e_oj_f(n));
 fprintf(fout,'       exch2_itlo_c(%d,%d)=%d\n',in,j,tile(j).e_itlo_l(n));
 fprintf(fout,'       exch2_ithi_c(%d,%d)=%d\n',in,j,tile(j).e_ithi_l(n));
 fprintf(fout,'       exch2_jtlo_c(%d,%d)=%d\n',in,j,tile(j).e_jtlo_l(n));
 fprintf(fout,'       exch2_jthi_c(%d,%d)=%d\n',in,j,tile(j).e_jthi_l(n));
 % Find corresponding target tile send entry from which I will receive
 % Need to know the send tiles edge, since same tile could send to this tile
 % from multiple edges. However there is only one send per remote tile for
 % any single edge.
 targetTile=tile(j).eTile(n);
 if tile(j).e_pi(n,:) == [0 1] & tile(j).e_pj(n,:) == [-1 0]
  % Opposing send wil be from targets south edge, find this tile in targets south edge list
  for k=1:tile(targetTile).nS
   if tile(targetTile).sTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+tile(targetTile).nN+tile(targetTile).nE+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 elseif tile(j).e_pi(n,:) == [1 0] & tile(j).e_pj(n,:) == [0 1]
  % Opposing send wil be from targets west edge, find this tile in targets west edge list
  for k=1:tile(targetTile).nW
   if tile(targetTile).wTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+tile(targetTile).nS+tile(targetTile).nE+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 else
  fprintf(fout,'ERROR MISSING CASE IN GENERATING CODE\n');
 end
end

for n=1:tile(j).nW
 fprintf(fout,'\n');
 in=in+1;
 fprintf(fout,'       exch2_neighbourId(%d,%d)=%d\n',in,j,tile(j).wTile(n));
 fprintf(fout,'       exch2_pi(1,%d,%d)=%d\n',in,j,tile(j).w_pi(n,1));
 fprintf(fout,'       exch2_pi(2,%d,%d)=%d\n',in,j,tile(j).w_pi(n,2));
 fprintf(fout,'       exch2_pj(1,%d,%d)=%d\n',in,j,tile(j).w_pj(n,1));
 fprintf(fout,'       exch2_pj(2,%d,%d)=%d\n',in,j,tile(j).w_pj(n,2));
 fprintf(fout,'       exch2_oi(%d,%d)=%d\n',in,j,tile(j).w_oi(n));
 fprintf(fout,'       exch2_oi_f(%d,%d)=%d\n',in,j,tile(j).w_oi_f(n));
 fprintf(fout,'       exch2_oj(%d,%d)=%d\n',in,j,tile(j).w_oj(n));
 fprintf(fout,'       exch2_oj_f(%d,%d)=%d\n',in,j,tile(j).w_oj_f(n));
 fprintf(fout,'       exch2_itlo_c(%d,%d)=%d\n',in,j,tile(j).w_itlo_l(n));
 fprintf(fout,'       exch2_ithi_c(%d,%d)=%d\n',in,j,tile(j).w_ithi_l(n));
 fprintf(fout,'       exch2_jtlo_c(%d,%d)=%d\n',in,j,tile(j).w_jtlo_l(n));
 fprintf(fout,'       exch2_jthi_c(%d,%d)=%d\n',in,j,tile(j).w_jthi_l(n));
 % Find corresponding target tile send entry from which I will receive
 % Need to know the send tiles edge, since same tile could send to this tile
 % from multiple edges. However there is only one send per remote tile for
 % any single edge.
 targetTile=tile(j).wTile(n);
 if tile(j).w_pi(n,:) == [0 1] & tile(j).w_pj(n,:) == [-1 0]
  % Send wil be from targets north edge, find this tile in targets north edge list
  for k=1:tile(targetTile).nN
   if tile(targetTile).nTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 elseif tile(j).w_pi(n,:) == [1 0] & tile(j).w_pj(n,:) == [0 1]
  % Send wil be from targets east edge, find this tile in targets east edge list
  for k=1:tile(targetTile).nE
   if tile(targetTile).eTile(k) == j
    % Formula for ir assumes tiles neighbors are written nW, nN, nE, nS
    ir=tile(targetTile).nW+tile(targetTile).nN+k;
    % Formula for ir assumes tiles neighbors are written nN, nS, nE, nW
    ir=tile(targetTile).nN+tile(targetTile).nS+k;
    fprintf(fout,'       exch2_opposingSend_record(%d,%d)=%d\n',in,j,ir);
   end
  end
 else
  fprintf(fout,'ERROR MISSING CASE IN GENERATING CODE\n');
 end
end

fprintf(fout,'       RETURN\n');
fprintf(fout,'       END\n');
fprintf(fout,'                                                  \n');
if outmode == 2
fclose(fout);
end
end
%fprintf(fout,'       exch2_pi(%d,1)=%d\n',j,tile(j).w_pi(1,1));
%fprintf(fout,'       exch2_pi(%d,2)=%d\n',j,tile(j).w_pi(1,2));
%end

%fprintf(fout,'       RETURN                                     \n');
%fprintf(fout,'       END                                        \n');
if outmode == 1
fclose(fout);
end

fout=fopen('test.F','w');
for j=1:length(tile)
 fprintf(fout,'       exch2_jthi_c(%d,%d)=%d\n',in,j,tile(j).s_jthi_l(n));
end

return
